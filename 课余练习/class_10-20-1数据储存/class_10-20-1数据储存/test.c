//#include<stdio.h>
//int main()
//{
//	int a = 20;    //00000000 00000000 00000000 00010100  因为是正数，所以原码反码补码一样
//	int b = -20;   //10000000 00000000 00000000 00010100  源码
//	               //11111111 11111111 11111111 11101011  反码
//	               //11111111 11111111 11111111 11101100  补码
//	               //内存调试： ec ff ff ff  ,所以为小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位,，保存在内存的高地址中。
//	               //将b取地址将得到它的最低地址（b占四个字节嘛，取地址只能得到最低那一个地址）
//	               
//	return 0;
//}

/*小程序判断当前机器的字节序（本编译器是大端存储还是小端存储）*/
//#include<stdio.h>
//int check_sys();
//int main()
//{
//	if (check_sys() == 1)
//	{
//		printf("为小端\n");
//	}
//	else
//		printf("为大端\n");
//	return 0;
//}
//int check_sys()
//{
//	int i = 1;
//	if (*(char*)&i == 1)    //先把i的地址强制转化为char*类型的指针，再解引用读出那里的值，相当于读出四个字节最小地址那一个的值
//	{                      //若改值等于一，说明最低权位（1）存在了最低地址，则为小---小----小，即小端存储模式；
//		return 1;
//	}
//	else
//		return 0;
//}


//#include<stdio.h>
//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	//a和b情况一样
//	//a:源码：1000 0001   反码:1111 1110  补码：1111 1111
//	//a要用%d输出（%d需要四个字节，所以要将a整形提升）
//	//a整形提升后为：11111111 11111111 11111111 11111111
//	//然后再输出（先转为反码：11111111 11111111 11111111 11111110）（再转为源码：100000000 00000000 00000000 00000001）
//	//最终源码的值就是-1，所以输出-1；
//	unsigned char c = -1;
//	//c:源码：1000 0001   反码:1111 1110  补码：1111 1111
//	//c要用%d输出（%d需要四个字节，所以要将c整形提升）
//	//c整形提升后为：00000000 00000000 00000000 11111111     因为c原类型为无符号，所以前面全部补0
//	//然后再输出（因为符号位为0，所以直接输出）
//	printf("a=%d\nb=%d\nc=%d\n", a, b, c);
//	return 0;
//}

//#include<stdio.h>
//int main()
//{
//	char a = -128;
//	//a在内存中为（补码）:1000 0000
//	//%u占四个字节，所以需要整形提升
//	//提升后内存中为：11111111 11111111 11111111 10000000       转为十进制为：4294967168（输出结果）
//	//因为为%u，无符号输出，所以输出直接输出（不用转为反码再转为源码），这里直接看成正数，正数原码反码补码一样嘛，所以直接输出
//	printf("%u\n", a);
//	return 0;
//}

//#include<stdio.h>
//int main()
//{
//	char a = 128;
//	printf("%u\n", a); //结果仍为4294967168   （11111111 11111111 11111111 10000000  ）
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);   //-10
//	return 0;
//}


//#include<stdio.h>
//#include<Windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)          //i永远为正嘛，肯定会死循环
//	{
//		printf("%u\n", i);         //9 8 7.....0 4294967295 4294967294 4294967293......
//		//printf("%x\n", i);
//		Sleep(500);            
//	}
//	return 0;
//}


//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;          //a[255] = -256  此时截断最高位后刚好为零，a[255] = 0(实际);
//
//	}
//	printf("%d\n", strlen(a));  //255
//	return 0;
//}

//#include<stdio.h>
//#include<math.h>
//int main()
//{
//	short num = 32767;        // num的补码：  01111111 11111111  
//	short int a = num + 1;    //a的补码：  10000000 00000000
//	printf("%d\n", a);        //因为按%d输出，所以先整形提升
//	                         //整形提升后：11111111 11111111 10000000 00000000（补码）
//	                         //            11111111 11111111 01111111 11111111（反码）
//	                          //           10000000 00000000 10000000 00000000   （-32768）输出结果：-32768
//	 
//	return 0;
//}


//#include<stdio.h>
//int main()
//{
//	char b = -128;     //内存窗口调试结果为：80   （即1000 0000）
//	short a = -32768;  //内存窗口调试结果为：00 80 （即10000000 00000000）
//	return 0;
//}